const _excluded = ["children", "className", "unmountOnExit"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import React from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
export const CollapsibleContext = /*#__PURE__*/React.createContext();
class CollapsibleAdvanced extends React.Component {
  static getDerivedStateFromProps(props) {
    if (props.open !== undefined) {
      return {
        // Since this method fires on both props and state changes, local updates
        // to the controlled value will be ignored, because the props version
        // always overrides it. In this case, this is exactly what we want.
        isOpen: props.open
      };
    }
    return null;
  }
  constructor(props) {
    super(props);
    _defineProperty(this, "open", () => {
      this.setState({
        isOpen: true
      });
      if (this.props.onOpen) {
        this.props.onOpen();
      }
      if (this.props.onToggle) {
        this.props.onToggle(true);
      }
    });
    _defineProperty(this, "close", () => {
      this.setState({
        isOpen: false
      });
      if (this.props.onClose) {
        this.props.onClose();
      }
      if (this.props.onToggle) {
        this.props.onToggle(false);
      }
    });
    _defineProperty(this, "toggle", () => {
      if (this.state.isOpen) {
        this.close();
      } else {
        this.open();
      }
    });
    this.state = {
      isOpen: props.open !== undefined ? props.open : props.defaultOpen
    };
  }
  render() {
    const _this$props = this.props,
      {
        children,
        className,
        unmountOnExit
      } = _this$props,
      props = _objectWithoutProperties(_this$props, _excluded);

    // Unneeded for passthrough props
    delete props.defaultOpen;
    delete props.onToggle;
    delete props.onOpen;
    delete props.onClose;
    return /*#__PURE__*/React.createElement("div", _extends({}, props, {
      className: classNames('pgn_collapsible', className, {
        'is-open': this.state.isOpen
      })
    }), /*#__PURE__*/React.createElement(CollapsibleContext.Provider, {
      value: {
        isOpen: this.state.isOpen,
        open: this.open,
        close: this.close,
        toggle: this.toggle,
        unmountOnExit
      }
    }, children));
  }
}
CollapsibleAdvanced.propTypes = {
  /** Specifies contents of the component. */
  children: PropTypes.node,
  /** Specifies classname to append to the base element. */
  className: PropTypes.string,
  /** Specifies whether `Collapsible` should be initially open. */
  defaultOpen: PropTypes.bool,
  /** Specifies whether `Collapsible` is open. */
  open: PropTypes.bool,
  /** Callback fired when `Collapsible's` state is toggled. */
  onToggle: PropTypes.func,
  /** Callback fired when `Collapsible` opens. */
  onOpen: PropTypes.func,
  /** Callback fired when `Collapsible` closes. */
  onClose: PropTypes.func,
  /** Unmount the component (remove it from the DOM) when it is collapsed. */
  unmountOnExit: PropTypes.bool
};
CollapsibleAdvanced.defaultProps = {
  children: undefined,
  className: undefined,
  defaultOpen: false,
  open: undefined,
  onToggle: undefined,
  onOpen: undefined,
  onClose: undefined,
  unmountOnExit: true
};
export default CollapsibleAdvanced;
//# sourceMappingURL=CollapsibleAdvanced.js.map