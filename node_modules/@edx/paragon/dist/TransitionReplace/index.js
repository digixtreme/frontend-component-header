function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import React from 'react';
import PropTypes from 'prop-types';
import { CSSTransition, TransitionGroup } from 'react-transition-group';
import classNames from 'classnames';
class TransitionReplace extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      height: null
    };
    this.onChildEnter = this.onChildEnter.bind(this);
    this.onChildEntering = this.onChildEntering.bind(this);
    this.onChildEntered = this.onChildEntered.bind(this);
    this.onChildExit = this.onChildExit.bind(this);
    this.onChildExiting = this.onChildExiting.bind(this);
    this.onChildExited = this.onChildExited.bind(this);
  }

  // Transition events are fired in this order:
  //
  // onEnter > onEntering > onEntered
  // onExit  > onExiting  > onExited
  //
  // Keep in mind that we always have two transitions happening
  // both the entering and leaving children
  //
  // We set the container height (for animation) in this order:
  //
  // 1. onChildExit         (explicitly set the height to match the current current)
  // 2. onChildEntering     (set the height to match the new content)
  // 3. onChildExited       (reset the height to null)

  onChildEnter(htmlNode) {
    if (this.props.onChildEnter) {
      this.props.onChildEnter(htmlNode);
    }
  }
  onChildEntering(htmlNode) {
    this.setState({
      height: htmlNode.offsetHeight
    });
    if (this.props.onChildEntering) {
      this.props.onChildEntering(htmlNode);
    }
  }
  onChildEntered(htmlNode) {
    this.setState({
      height: null
    });
    if (this.props.onChildEntered) {
      this.props.onChildEntered(htmlNode);
    }
  }
  onChildExit(htmlNode) {
    this.setState({
      height: htmlNode.offsetHeight
    });
    if (this.props.onChildExit) {
      this.props.onChildExit(htmlNode);
    }
  }
  onChildExiting(htmlNode) {
    if (this.props.onChildExiting) {
      this.props.onChildExiting(htmlNode);
    }
  }
  onChildExited(htmlNode) {
    this.setState({
      height: null
    });
    if (this.props.onChildExited) {
      this.props.onChildExited(htmlNode);
    }
  }
  renderChildTransition(child) {
    if (!child.key && process.env.NODE_ENV === 'development') {
      // eslint-disable-next-line no-console
      console.warn("TransitionReplace: A child is missing a 'key' prop. Keys are required for any child of this component.");
    }
    // Makes the exiting and entering children occupy the same space
    // SCSS handles the crossfade so it can be easily overridden
    const commonChildStyles = {
      // Prevent margin-collapsing which throws off height calculations
      padding: '.1px 0'
    };
    const transitionStyles = {
      entering: {},
      entered: {},
      exiting: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        pointerEvents: 'none'
      },
      exited: {}
    };
    return /*#__PURE__*/React.createElement(CSSTransition, {
      timeout: {
        enter: this.props.enterDuration,
        exit: this.props.exitDuration
      },
      unmountOnExit: true,
      mountOnEnter: true,
      onEnter: this.onChildEnter,
      onEntering: this.onChildEntering,
      onEntered: this.onChildEntered,
      onExit: this.onChildExit,
      onExiting: this.onChildExiting,
      onExited: this.onChildExited,
      classNames: this.props.transitionClassNames
    }, state => /*#__PURE__*/React.createElement("div", {
      style: _objectSpread(_objectSpread(_objectSpread({}, commonChildStyles), transitionStyles[state]), this.props.transitionStyles[state])
    }, child));
  }
  render() {
    return /*#__PURE__*/React.createElement(TransitionGroup, {
      className: classNames('pgn-transition-replace-group', 'position-relative', {
        'overflow-hidden': this.state.height !== null
      }, this.props.className),
      style: {
        height: this.state.height
      }
    }, React.Children.map(this.props.children, this.renderChildTransition, this));
  }
}
TransitionReplace.propTypes = {
  /** Specifies an additional class for the base element */
  children: PropTypes.element,
  /** Duration of the element appearance transition. */
  enterDuration: PropTypes.number,
  /** Duration of the element dismiss transition. */
  exitDuration: PropTypes.number,
  /** Specifies class name to append to the base element. */
  className: PropTypes.string,
  /** A `Transition` callback fired immediately after the `enter` or `appear` class is applied. */
  onChildEnter: PropTypes.func,
  /** A `Transition` callback fired immediately after the `enter-active` or `appear-active` class is applied. */
  onChildEntering: PropTypes.func,
  /**
   * A `Transition` callback fired immediately after the `enter` or
   * `appear` classes are removed and the done class is added to the DOM node.
   */
  onChildEntered: PropTypes.func,
  /** A `Transition` callback fired immediately after the `exit` class is applied. */
  onChildExit: PropTypes.func,
  /** A `Transition` callback fired immediately after the `exit-active` is applied. */
  onChildExiting: PropTypes.func,
  /**
   * A `Transition` callback fired immediately after the `exit` classes
   * are removed and the exit-done class is added to the DOM node.
   */
  onChildExited: PropTypes.func,
  /** An object that specifies transition styles. */
  transitionStyles: PropTypes.shape({
    entering: PropTypes.shape({}),
    entered: PropTypes.shape({}),
    exiting: PropTypes.shape({}),
    exited: PropTypes.shape({})
  }),
  /** Specifies class name to append to the `Transition`. */
  transitionClassNames: PropTypes.string
};
TransitionReplace.defaultProps = {
  children: undefined,
  enterDuration: 300,
  exitDuration: 300,
  className: undefined,
  onChildEnter: undefined,
  onChildEntering: undefined,
  onChildEntered: undefined,
  onChildExit: undefined,
  onChildExiting: undefined,
  onChildExited: undefined,
  transitionStyles: {},
  transitionClassNames: 'pgn__transition-replace'
};
export default TransitionReplace;
//# sourceMappingURL=index.js.map