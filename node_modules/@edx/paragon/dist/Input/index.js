const _excluded = ["value", "label", "group"],
  _excluded2 = ["type", "className", "options", "forwardedRef"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
class Input extends React.Component {
  componentDidMount() {
    if (process.env.NODE_ENV === 'development') {
      this.checkHasLabel();
    }
  }
  getHTMLTagForType() {
    const {
      type
    } = this.props;
    if (type === 'select' || type === 'textarea') {
      return type;
    }
    return 'input';
  }
  getClassNameForType() {
    switch (this.props.type) {
      case 'file':
        return 'form-control-file';
      case 'checkbox':
      case 'radio':
        return 'form-check-input';
      default:
        return 'form-control';
    }
  }
  setRef(forwardedRef) {
    // In production just return the optional forwardedRef
    if (process.env.NODE_ENV !== 'development') {
      return forwardedRef;
    }
    return element => {
      if (forwardedRef) {
        forwardedRef.current = element;
      } // eslint-disable-line no-param-reassign
      this.inputEl = element;
    };
  }
  checkHasLabel() {
    if (this.inputEl.labels.length > 0) {
      return;
    }
    if (this.inputEl.getAttribute('aria-label') !== null) {
      return;
    }
    if (this.inputEl.getAttribute('aria-labelledby') !== null) {
      return;
    }
    if (console) {
      // eslint-disable-next-line no-console
      console.warn('Input[a11y]: There is no associated label for this Input');
    }
  }
  renderOptions(options) {
    return options.map(option => {
      const {
          value,
          label,
          group
        } = option,
        attributes = _objectWithoutProperties(option, _excluded);
      if (group) {
        return /*#__PURE__*/React.createElement("optgroup", _extends({
          key: `optgroup-${label}`,
          label: label
        }, attributes), this.renderOptions(group));
      }
      return /*#__PURE__*/React.createElement("option", _extends({
        key: value,
        value: value
      }, attributes), label);
    }, this);
  }
  render() {
    const _this$props = this.props,
      {
        type,
        className,
        options,
        forwardedRef // eslint-disable-line react/prop-types
        // eslint-disable-line react/prop-types
      } = _this$props,
      attributes = _objectWithoutProperties(_this$props, _excluded2);
    const htmlTag = this.getHTMLTagForType();
    const htmlProps = _objectSpread(_objectSpread({
      className: classNames(this.getClassNameForType(), className),
      type: htmlTag === 'input' ? type : undefined
    }, attributes), {}, {
      ref: this.setRef(forwardedRef)
    });
    const htmlChildren = type === 'select' ? this.renderOptions(options) : null;
    return /*#__PURE__*/React.createElement(htmlTag, htmlProps, htmlChildren);
  }
}
Input.propTypes = {
  /** specifies the type of component.
   * One of select, textarea, or any valid type for an html input tag. */
  type: PropTypes.oneOf(['textarea', 'select', 'checkbox', 'color', 'date', 'datetime', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week']).isRequired,
  /** specifies the className in addition to a bootstrap class name. */
  className: PropTypes.string,
  /** should be used to specify the options of an Input of type select */
  options: PropTypes.arrayOf(PropTypes.shape({
    label: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    disabled: PropTypes.bool,
    group: PropTypes.arrayOf(PropTypes.shape({
      label: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      disabled: PropTypes.bool
    }))
  }))
};
Input.defaultProps = {
  className: undefined,
  options: []
};

// eslint-disable-next-line react/no-multi-comp
const InputWithRefForwarding = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(Input, _extends({
  forwardedRef: ref
}, props)));
export default InputWithRefForwarding;
//# sourceMappingURL=index.js.map